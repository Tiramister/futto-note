## Context

Step 1 で環境構築が完了し、バックエンド（Go）、フロントエンド（React + Vite）、データベース（PostgreSQL）の基盤が整った。`users` と `sessions` テーブルは既に作成済み。次のステップとして、ユーザーがログインしてセッションを維持できる認証機構を実装する。

現状:
- バックエンドは `/api/health` のみ実装
- フロントエンドはヘルスチェックページのみ
- ユーザー登録は `create_user.go` CLI ツールで行う（Web UI は範囲外）

## Goals / Non-Goals

**Goals:**
- Cookie ベースのセッション認証を実装する
- ログイン、ログアウト、セッション確認の API を提供する
- フロントエンドでログイン画面と認証状態管理を実装する
- 以降のメッセージ系 API で使用する認証ミドルウェアを用意する

**Non-Goals:**
- ユーザー登録の Web UI（CLI ツールで対応）
- パスワードリセット機能
- OAuth / ソーシャルログイン
- JWT の使用（シンプルなセッショントークン方式を採用）
- Remember me 機能（固定30日の有効期限）

## Decisions

### 1. セッショントークンの形式

**決定**: `crypto/rand` で生成した 32 バイトのランダム値を hex エンコード（64文字）

**理由**:
- シンプルで予測不可能
- UUID より衝突確率が低い
- Base64 より URL-safe で扱いやすい

**代替案**:
- UUID v4: 衝突確率は十分低いが、ランダムバイトの方が情報量が多い
- JWT: ステートレスだが、ログアウト時の即時無効化が複雑になる

### 2. Cookie の設定

**決定**:
- `HttpOnly`: true（XSS 対策）
- `Secure`: 本番環境のみ true（開発時は localhost なので false）
- `SameSite`: Strict（CSRF 対策）
- `Path`: `/`
- `Max-Age`: 30日（2,592,000 秒）

**理由**:
- セキュリティのベストプラクティスに従う
- 開発時の利便性と本番のセキュリティを両立

### 3. 認証ミドルウェアの設計

**決定**: Go の `http.Handler` をラップするミドルウェア関数として実装し、`context.Context` に `user_id` を埋め込む

**理由**:
- 標準ライブラリの慣習に沿った設計
- chi ルーターと互換性がある
- ハンドラー側で `context.Value` からユーザー ID を取得可能

### 4. フロントエンドの認証状態管理

**決定**: React の useState と useEffect で管理。起動時に `/api/me` を呼び出して認証状態を確認する

**理由**:
- シンプルで依存関係が少ない
- 単一ユーザー想定のためグローバル状態管理ライブラリは不要

**代替案**:
- React Context: 今後の拡張で必要になれば追加
- Redux / Zustand: 現時点ではオーバーキル

### 5. ルーティング

**決定**: 条件分岐で認証状態に応じてログイン画面 or メイン画面を表示（React Router は使用しない）

**理由**:
- 画面が2つ（ログイン / メイン）だけなので、ルーターを導入する必要がない
- 依存関係を最小限に保つ

## Risks / Trade-offs

**[Risk] セッションの固定有効期限（30日）**
→ 30日後に強制ログアウトされる。Mitigation: 必要に応じてアクティビティベースの延長を将来実装

**[Risk] 開発環境で Secure=false**
→ ローカル開発では HTTPS を使わないため。Mitigation: 環境変数で本番/開発を判別し、本番では必ず Secure=true

**[Risk] セッションテーブルの肥大化**
→ ログアウトせずに放置されたセッションが残る。Mitigation: 定期的なクリーンアップジョブ（将来対応）

**[Trade-off] JWT を使わない**
→ サーバーサイドでセッション管理が必要。利点: 即時ログアウトが簡単、シンプルな実装
