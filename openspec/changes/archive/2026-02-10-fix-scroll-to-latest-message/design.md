## Context

`message-timeline-view` では「初回表示時に最新メッセージへスクロール」「送信成功後に最下部へスクロール」が要件として定義されているが、実装上はスクロール実行タイミングが描画完了より早くなるケースがあり、最新メッセージまで到達しない不具合が発生している。

現在のフロントエンドは以下の構成でスクロールしている。
- 初回表示: `useMessages` の `useEffect` で `scrollTop = scrollHeight` を 1 回実行
- 送信成功時: `App.tsx` で `appendMessage` 後に `setTimeout(..., 0)` で `scrollToBottom` 実行

この分散した制御だと、DOM 反映やレイアウト確定前にスクロールが走ると 1 件前で止まる。バックエンドやデータモデル変更は不要で、フロントエンドのスクロール制御を一元化して解決する。

## Goals / Non-Goals

**Goals:**
- 初回表示時に、常に最新メッセージが表示領域に入るスクロールを保証する。
- 送信成功時に、追加された新規メッセージまで必ずスクロールする。
- スクロール処理をタイミング依存の `setTimeout` から切り離し、描画後に確実実行できる構造へ変更する。
- 既存テストを拡張し、初回表示と送信後のスクロール到達先を検証する。

**Non-Goals:**
- メッセージ順序（昇順表示）や API 契約の変更。
- メッセージ編集・削除など他機能への拡張。
- 無限スクロールやページネーションの導入。

## Decisions

### 1. スクロール対象を「コンテナ高さ」ではなく「最新メッセージ要素」にする

- 決定: 最新メッセージ要素への参照を持ち、`scrollIntoView({ block: "end" })` を基本手段として使用する。
- 理由: `scrollHeight` ベースは描画タイミング次第で古い高さを参照しうるが、要素基準なら「どのメッセージを表示すべきか」が直接表現できる。
- 代替案: `scrollTop = scrollHeight` を `setTimeout` や `requestAnimationFrame` で遅延させる方法は、環境依存の調整が必要で安定性が低いため不採用。

### 2. スクロール要求を `useMessages` に集約し、描画後に 1 回実行する

- 決定: `useMessages` 内に「初回表示」「送信成功」のスクロール要求フラグを持たせ、メッセージ描画後の Effect で実行する。
- 理由: 呼び出し元コンポーネントからタイミング制御を排除でき、再利用と保守性が上がる。
- 代替案: `App.tsx` から都度スクロール関数を直接呼ぶ方式は、更新順序に依存した不具合を再発させやすく不採用。

### 3. 送信後更新 API を「追加 + スクロール予約」の単一操作に寄せる

- 決定: 送信成功時はメッセージ追加とスクロール要求を同じ責務で扱う。
- 理由: 「追加はしたがスクロール予約し忘れた」不整合を防ぎ、要件を満たす操作単位を明確にできる。
- 代替案: 既存の `appendMessage` と `scrollToBottom` を分離維持する方式は、呼び出し順序やタイミングのミスが残るため不採用。

### 4. テストは到達先を明示的に検証する

- 決定: 初回表示と送信後それぞれで「最新メッセージが表示対象になること」をテストする。
- 理由: 単純な `scrollTop` 値比較だけでは、DOM 更新順に起因する取りこぼしを検知しづらい。
- 代替案: 手動確認のみでは回帰を防げないため不採用。

## Risks / Trade-offs

- [Risk] `scrollIntoView` のテスト環境差異で偽陽性/偽陰性が出る  
  → Mitigation: テストでは必要に応じてメソッドをモックし、呼び出し対象と回数を検証する。
- [Risk] Effect の依存管理を誤ると不要な再スクロールが発生する  
  → Mitigation: スクロール要求フラグを消費型にし、1 要求につき 1 回のみ実行する。
- [Trade-off] 参照管理（最新要素 ref）が増えて実装はやや複雑になる  
  → 利点: スクロール到達先の保証が強くなり、要件に直接対応できる。

## Migration Plan

1. `MessageList` で最新メッセージ要素を参照可能にする。
2. `useMessages` にスクロール要求管理を追加し、初回表示・送信成功時の処理を集約する。
3. `App.tsx` から `setTimeout` ベースのスクロール呼び出しを削除する。
4. フロントエンドテストを更新し、初回表示と送信後のスクロールを検証する。

ロールバックはフロントエンド変更の巻き戻しのみで可能。DB/API の移行作業は不要。

## Open Questions

- なし
