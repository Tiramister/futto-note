## Context

既存のタイムラインはメッセージ本文・投稿時刻・URLリンク化を提供しているが、日付境界の視覚的区切りがないため、複数日にまたがる履歴の読解コストが高い。  
本変更はフロントエンド描画ロジックのみを対象とし、`GET /api/messages` のレスポンス形式やデータモデルは変更しない。

## Goals / Non-Goals

**Goals:**
- メッセージ配列を時系列で描画する際、日付が変わる位置にのみセパレーターを表示する。
- セパレーターの日付表示をロケール非依存の固定 `yyyy/MM/dd` 形式に統一する。
- メッセージが存在しない日付を補間したセパレーターを表示しないことを保証する。
- 表示仕様をフロントエンドテストで検証可能にする。

**Non-Goals:**
- バックエンド API / DB スキーマ / 認証仕様の変更。
- タイムライン全体のレイアウト刷新やデザインテーマ変更。
- 日付セパレーター以外の本文レンダリング仕様変更（URLリンク化など）。

## Decisions

### 1. セパレーター挿入判定は隣接メッセージ比較で行う

- 方針: ソート済みメッセージを先頭から走査し、各メッセージの表示日付キーを直前メッセージと比較する。  
  先頭メッセージ、または日付キーが変化した場合のみセパレーターを挿入する。
- 理由: 実装が単純で計算量が O(n) に収まり、欠損日（例: 1/17 にメッセージなし）を補間する余地を作らない。
- 代替案:
  - カレンダー日付を連続生成して差分を埋める案は、要件「メッセージが無い日付は表示しない」に反するため不採用。

### 2. 表示フォーマットは `yyyy/MM/dd` 固定にする

- 方針: `Intl.DateTimeFormat` のロケール依存出力は使わず、年・月・日をゼロ埋めして `yyyy/MM/dd` 文字列を組み立てる。
- 理由: ユーザー指定の「言語非依存フォーマット」を確実に満たせる。
- 代替案:
  - ロケールを `en-CA` などに固定して `Intl` を使う案は、環境差分の解釈が入りうるため不採用。

### 3. 日付境界判定に使うタイムゾーンは既存時刻表示と揃える

- 方針: セパレーター判定と日付文字列生成は、既存の投稿時刻表示と同じタイムゾーン基準（クライアント表示基準）で扱う。
- 理由: 同一画面内で時刻と日付境界の解釈が食い違うことを防ぐ。
- 代替案:
  - UTC 固定は一貫性はあるが、既存の時刻表示基準とズレる可能性があるため不採用。

## Risks / Trade-offs

- [Risk] 既存時刻表示のタイムゾーン仕様が暗黙的な場合、境界判定との整合が崩れる可能性  
  → Mitigation: 既存時刻表示の実装基準を確認し、同一関数/同一基準を再利用する。
- [Risk] 日付フォーマット関数を個別実装すると他表示箇所との重複が発生する  
  → Mitigation: フォーマット処理をユーティリティ化し、セパレーター表示でのみ責務を限定して利用する。
